<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VibeCall</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .container {
            background: white;
            border-radius: 16px;
            padding: 30px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 500px;
            width: 100%;
            margin-bottom: 20px;
        }

        h1 {
            color: #333;
            margin-bottom: 20px;
            text-align: center;
        }

        .input-group {
            margin-bottom: 15px;
        }

        label {
            display: block;
            color: #555;
            margin-bottom: 5px;
            font-weight: 500;
        }

        input {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            font-size: 14px;
            transition: border-color 0.3s;
        }

        input:focus {
            outline: none;
            border-color: #667eea;
        }

        .btn {
            width: 100%;
            padding: 12px;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 10px;
        }

        .btn-primary {
            background: #667eea;
            color: white;
        }

        .btn-primary:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4);
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .status {
            padding: 10px;
            border-radius: 8px;
            margin-top: 15px;
            text-align: center;
            font-weight: 500;
        }

        .status.connected {
            background: #d1fae5;
            color: #065f46;
        }

        .status.disconnected {
            background: #fee2e2;
            color: #991b1b;
        }

        .video-container {
            background: #1a1a1a;
            border-radius: 16px;
            padding: 20px;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            max-width: 1200px;
            width: 100%;
            display: none;
        }

        .video-container.active {
            display: block;
        }

        .videos {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 20px;
            margin-bottom: 20px;
        }

        .video-wrapper {
            position: relative;
            background: #000;
            border-radius: 12px;
            overflow: hidden;
            aspect-ratio: 16/9;
        }

        video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 5px 10px;
            border-radius: 6px;
            font-size: 14px;
        }

        .users-list {
            color: white;
            margin-top: 15px;
            padding: 15px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 8px;
        }

        .users-list h3 {
            margin-bottom: 10px;
            font-size: 16px;
        }

        .user-item {
            padding: 5px 0;
            font-size: 14px;
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>ðŸŽ¥ VibeCall</h1>

        <div class="input-group">
            <label>User ID</label>
            <input type="number" id="userId" value="1" min="1">
        </div>

        <div class="input-group">
            <label>Room ID</label>
            <input type="text" id="roomId" value="d7694d42-2fea-4f14-a086-add07a7bf876">
        </div>

        <button class="btn btn-primary" id="connectBtn">Connect & Join Call</button>
        <button class="btn btn-danger" id="leaveBtn" disabled>Leave Call</button>

        <div class="status disconnected" id="status">Disconnected</div>
    </div>

    <div class="video-container" id="videoContainer">
        <div class="videos">
            <div class="video-wrapper">
                <video id="localVideo" autoplay muted playsinline></video>
                <div class="video-label">You (Local)</div>
            </div>
            <div class="video-wrapper" id="remoteVideoWrapper" style="display: none;">
                <video id="remoteVideo" autoplay playsinline></video>
                <div class="video-label">Remote User</div>
            </div>
        </div>

        <div class="users-list" id="usersList">
            <h3>Connected Users</h3>
            <div id="usersContent">None</div>
        </div>
    </div>

    <script>
        // WebRTC configuration
        const configuration = {
            iceServers: [
                {urls: 'stun:stun.l.google.com:19302'},
                {urls: 'stun:stun1.l.google.com:19302'}
            ]
        };

        let ws = null;
        let peerConnection = null;
        let localStream = null;
        let userId = null;
        let roomId = null;
        let remoteUserId = null;

        const connectBtn = document.getElementById('connectBtn');
        const leaveBtn = document.getElementById('leaveBtn');
        const status = document.getElementById('status');
        const videoContainer = document.getElementById('videoContainer');
        const localVideo = document.getElementById('localVideo');
        const remoteVideo = document.getElementById('remoteVideo');
        const remoteVideoWrapper = document.getElementById('remoteVideoWrapper');
        const usersContent = document.getElementById('usersContent');

        connectBtn.addEventListener('click', connect);
        leaveBtn.addEventListener('click', leave);

        async function connect() {
            userId = parseInt(document.getElementById('userId').value);
            roomId = document.getElementById('roomId').value;
            const serverUrl = "ws://localhost:8085/call/ws/rooms";

            if (!userId || !roomId) {
                alert('Please enter User ID and Room ID');
                return;
            }

            try {
                const turnResponse = await fetch(
                    `http://localhost:8085/turn-credentials?user_id=${userId}`
                );
                const turnConfig = await turnResponse.json();

                console.log('TURN credentials received:', turnConfig);

                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });
                localVideo.srcObject = localStream;
                videoContainer.classList.add('active');

                configuration.iceServers = [
                    {urls: 'stun:stun.l.google.com:19302'},
                    {
                        urls: turnConfig.urls,
                        username: turnConfig.username,
                        credential: turnConfig.credential
                    }
                ];

                // Connect WebSocket
                ws = new WebSocket(`${serverUrl}/${roomId}?user_id=${userId}`);

                ws.onopen = () => {
                    console.log('WebSocket connected');
                    updateStatus('Connected', true);

                    // Send join message
                    sendMessage({
                        type: 'join',
                        room_id: roomId,
                        user_id: userId
                    });

                    connectBtn.disabled = true;
                    leaveBtn.disabled = false;
                };

                ws.onmessage = handleMessage;

                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    updateStatus('Connection Error', false);
                };

                ws.onclose = () => {
                    console.log('WebSocket closed');
                    updateStatus('Disconnected', false);
                    cleanup();
                };

            } catch (error) {
                console.error('Error accessing media devices:', error);
                alert('Could not access camera/microphone. Please grant permissions.');
            }
        }

        async function handleMessage(event) {
            const message = JSON.parse(event.data);
            console.log('Received message:', message);

            switch (message.type) {
                case 'user-joined':
                    handleUserJoined(message);
                    break;
                case 'user-left':
                    handleUserLeft(message);
                    break;
                case 'offer':
                    await handleOffer(message);
                    break;
                case 'answer':
                    await handleAnswer(message);
                    break;
                case 'ice-candidate':
                    await handleIceCandidate(message);
                    break;
                case 'error':
                    console.error('Server error:', message.message);
                    alert('Error: ' + message.message);
                    break;
            }
        }

        function handleUserJoined(message) {
            console.log('=== USER JOINED EVENT ===');
            console.log('Users in room:', message.users);
            console.log('My user ID:', userId);
            console.log('Joining user ID:', message.user_id);

            updateUsersList(message.users);

            // If there's another user, create offer
            const otherUsers = message.users.filter(id => id !== userId);
            console.log('Other users:', otherUsers);
            console.log('Already have peer connection?', !!peerConnection);
            console.log('Should create offer?', otherUsers.length > 0 && !peerConnection && message.user_id !== userId);

            // Only create offer if: 1) there are other users, 2) no connection yet, 3) I'm not the one who just joined
            if (otherUsers.length > 0 && !peerConnection && message.user_id !== userId) {
                remoteUserId = otherUsers[0];
                console.log('>>> Creating peer connection and offer to user:', remoteUserId);
                createPeerConnection();
                createOffer();
            }
        }

        function handleUserLeft(message) {
            console.log('User left:', message.user_id);
            if (message.user_id === remoteUserId) {
                remoteVideoWrapper.style.display = 'none';
                if (peerConnection) {
                    peerConnection.close();
                    peerConnection = null;
                }
                remoteUserId = null;
            }
        }

        function createPeerConnection() {
            peerConnection = new RTCPeerConnection(configuration);

            // Add local stream tracks
            localStream.getTracks().forEach(track => {
                peerConnection.addTrack(track, localStream);
            });

            // Handle remote stream
            peerConnection.ontrack = (event) => {
                console.log('Received remote track');
                remoteVideo.srcObject = event.streams[0];
                remoteVideoWrapper.style.display = 'block';
            };

            // Handle ICE candidates
            peerConnection.onicecandidate = (event) => {
                if (event.candidate) {
                    console.log('Sending ICE candidate');
                    sendMessage({
                        type: 'ice_candidate',
                        target_user_id: remoteUserId,
                        candidate: event.candidate.candidate,
                        sdp_mid: event.candidate.sdpMid,
                        sdp_m_line_index: event.candidate.sdpMLineIndex
                    });
                }
            };

            peerConnection.onconnectionstatechange = () => {
                console.log('Connection state:', peerConnection.connectionState);
            };
        }

        async function createOffer() {
            try {
                const offer = await peerConnection.createOffer();
                await peerConnection.setLocalDescription(offer);

                console.log('Sending offer');
                sendMessage({
                    type: 'offer',
                    target_user_id: remoteUserId,
                    sdp: offer.sdp
                });
            } catch (error) {
                console.error('Error creating offer:', error);
            }
        }

        async function handleOffer(message) {
            remoteUserId = message.from;

            if (!peerConnection) {
                createPeerConnection();
            }

            try {
                await peerConnection.setRemoteDescription({
                    type: 'offer',
                    sdp: message.sdp
                });

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                console.log('Sending answer');
                sendMessage({
                    type: 'answer',
                    target_user_id: remoteUserId,
                    sdp: answer.sdp
                });
            } catch (error) {
                console.error('Error handling offer:', error);
            }
        }

        async function handleAnswer(message) {
            try {
                await peerConnection.setRemoteDescription({
                    type: 'answer',
                    sdp: message.sdp
                });
                console.log('Answer set successfully');
            } catch (error) {
                console.error('Error handling answer:', error);
            }
        }

        async function handleIceCandidate(message) {
            try {
                if (peerConnection) {
                    await peerConnection.addIceCandidate({
                        candidate: message.candidate,
                        sdpMid: message.sdp_mid,
                        sdpMLineIndex: message.sdp_m_line_index
                    });
                    console.log('ICE candidate added');
                }
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        }

        function sendMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            }
        }

        function leave() {
            if (ws) {
                sendMessage({
                    type: 'leave',
                    room_id: roomId
                });
                ws.close();
            }
            cleanup();
        }

        function cleanup() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            if (peerConnection) {
                peerConnection.close();
                peerConnection = null;
            }

            videoContainer.classList.remove('active');
            remoteVideoWrapper.style.display = 'none';
            connectBtn.disabled = false;
            leaveBtn.disabled = true;
            remoteUserId = null;
        }

        function updateStatus(text, connected) {
            status.textContent = text;
            status.className = 'status ' + (connected ? 'connected' : 'disconnected');
        }

        function updateUsersList(users) {
            console.log('Updating users list with:', users);
            if (!users || users.length === 0) {
                usersContent.textContent = 'None';
            } else {
                usersContent.innerHTML = users.map(id =>
                    `<div class="user-item">ðŸ‘¤ User ${id}${id === userId ? ' (You)' : ''}</div>`
                ).join('');
            }
        }
    </script>
</body>

</html>
