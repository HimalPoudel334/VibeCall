{% extends "base.html" %}

{% block title %}Video Call - VibeCall{% endblock %}

{% block content %}
<style>
    nav { display: none !important; }
</style>

<div class="h-screen w-screen bg-teal-900/90 flex flex-col">
    <!-- Main Video Area -->
    <div class="flex-1 relative overflow-hidden" style="min-height: 0;">
        <!-- Remote Video (other users) -->
        <div id="remoteVideos" class="w-full h-full grid gap-0.5 sm:gap-1 p-0.5 sm:p-1 overflow-auto" style="max-height: calc(100vh - 80px);">
            <!-- Remote videos will be placed here -->
        </div>

        <div id="localVideoContainer" class="absolute bottom-4 right-4 w-48 h-36 sm:w-56 sm:h-40 md:w-64 md:h-48 lg:w-72 lg:h-52 bg-gray-800 rounded-lg overflow-hidden border-2 border-teal-500 shadow-lg z-10" style="max-height: 200px; max-width: 300px;">
            <video id="localVideo" class="w-full h-full object-cover" autoplay muted></video>
            <div class="absolute bottom-2 left-2 bg-black/70 text-white px-2 py-1 rounded text-xs sm:text-sm">You</div>
        </div>

        <!-- Users List Panel (initially hidden) -->
        <div id="usersListPanel" class="absolute top-20 right-4 bg-black/90 backdrop-blur-sm text-white p-4 rounded-lg w-80 hidden">
            <h3 class="text-teal-400 font-semibold mb-3 border-b border-teal-600 pb-2">Connected Users</h3>
            <div id="usersContent" class="space-y-2 max-h-64 overflow-y-auto">
                <div class="flex items-center justify-between p-2 bg-gray-800 rounded">
                    <span>user1</span>
                    <div class="w-2 h-2 bg-teal-500 rounded-full"></div>
                </div>
            </div>
        </div>

        <!-- Users Message Panel (initially hidden) -->
        <div id="userMessagePanel" class="absolute space-y-3 top-20 right-4 bg-black/90 backdrop-blur-sm text-white p-4 rounded-lg w-80 hidden">
            <h3 class="text-teal-400 font-semibold mb-3 border-b border-teal-600 pb-2">Messages</h3>
            <div id="messageContent" class="space-y-2 max-h-64 overflow-y-auto">
                <div class="flex items-center justify-between p-2 bg-gray-800 rounded">
                    <span>user1</span>
                    <div class="w-2 h-2 bg-teal-500 rounded-full"></div>
                </div>
                <div class="flex items-center justify-between p-2 bg-gray-800 rounded">
                    <span>user2</span>
                    <div class="w-2 h-2 bg-teal-500 rounded-full"></div>
                </div>
            </div>
            <div class="flex items-center space-x-2">
                <input
                    type="text"
                    id="userMessageInput"
                    placeholder="Type a message..."
                    class="flex-1 px-3 py-1 rounded bg-gray-700 text-white placeholder-gray-400 focus:outline-none focus:ring-2 focus:ring-teal-500"
                />
                <button
                    id="sendUserMessage"
                    class="text-teal-400 hover:text-teal-300 transition"
                    title="Send Message"
                >
                    <i class="fas fa-paper-plane"></i>
                </button>
            </div>
        </div>
    </div>

    <!-- Controls -->
    <div class="py-4 flex items-center justify-center bg-teal-900/90" style="height: 80px;">
        <div class="flex items-center gap-2 sm:gap-3 md:gap-4 flex-wrap justify-center max-w-[90vw]">
            <button id="toggleMicBtn" class="w-10 h-10 sm:w-12 sm:h-12 md:w-14 md:h-14 rounded-full bg-gray-600 text-white flex items-center justify-center transition-all duration-200 hover:scale-110" title="Toggle Mic">
                <i id="micIcon" class="fa-solid fa-microphone text-xs sm:text-sm md:text-lg"></i>
            </button>
            <button id="toggleVideoBtn" class="w-10 h-10 sm:w-12 sm:h-12 md:w-14 md:h-14 rounded-full bg-gray-600 text-white flex items-center justify-center transition-all duration-200 hover:scale-110" title="Toggle Video">
                <i id="videoIcon" class="fa-solid fa-video text-xs sm:text-sm md:text-lg"></i>
            </button>
            <button id="flipCameraBtn" class="w-10 h-10 sm:w-12 sm:h-12 md:w-14 md:h-14 rounded-full bg-gray-600 text-white flex items-center justify-center transition-all duration-200 hover:scale-110" title="Flip Camera">
                <i class="fa-solid fa-camera-rotate text-xs sm:text-sm md:text-lg"></i>
            </button>
            <button id="userMessageBtn" class="w-10 h-10 sm:w-12 sm:h-12 md:w-14 md:h-14 rounded-full bg-gray-600 text-white flex items-center justify-center transition-all duration-200 hover:scale-110" title="Messages">
                <i class="fa-solid fa-comment text-xs sm:text-sm md:text-lg"></i>
            </button>
            <button id="usersListToggle" class="w-10 h-10 sm:w-12 sm:h-12 md:w-14 md:h-14 rounded-full bg-teal-600 text-white flex items-center justify-center transition-all duration-200 hover:scale-110" title="Users List">
                <i class="fa-solid fa-users text-xs sm:text-sm md:text-lg"></i>
            </button>
            <button id="endCallBtn" class="w-10 h-10 sm:w-12 sm:h-12 md:w-14 md:h-14 rounded-full bg-red-600 hover:bg-red-500 text-white flex items-center justify-center transition-all duration-200 hover:scale-110" title="End Call">
                <i class="fa-solid fa-phone text-xs sm:text-sm md:text-lg"></i>
            </button>
        </div>
    </div>
</div>

<script>
    let ws = null;
    let peerConnections = {};
    let localStream = null;
    const remoteStreams = {}; // Track streams by user ID

    // VIDEO TOGGLE
    const toggleVideoBtn = document.getElementById('toggleVideoBtn');
    // VIDEO TOGGLE
    toggleVideoBtn.addEventListener('click', async function () {
        const videoBtn = this;
        const videoIcon = document.getElementById('videoIcon');
        const localVideoContainer = document.getElementById('localVideoContainer');
        const localVideoElement = document.getElementById('localVideo');
        
        if (!localStream) return;
        
        const videoTracks = localStream.getVideoTracks();
        const isVideoEnabled = videoTracks.length > 0 && videoTracks[0].readyState === 'live';
        
        if (isVideoEnabled) {
            // ===== TURN VIDEO OFF =====
            videoTracks.forEach(track => {
                track.stop();
                localStream.removeTrack(track);
            });
            
            // Update peer connections - remove video track
            if (typeof peerConnections !== 'undefined') {
                Object.values(peerConnections).forEach(pc => {
                    const senders = pc.getSenders();
                    senders.forEach(sender => {
                        if (sender.track && sender.track.kind === 'video') {
                            pc.removeTrack(sender);
                        }
                    });
                });
            }
            
            // Properly release video element
            localVideoElement.pause();
            localVideoElement.srcObject = null;
            localVideoElement.load();
            
            videoBtn.classList.add('bg-red-600');
            videoIcon.className = 'fa-solid fa-video-slash text-xs sm:text-sm md:text-lg';
            
            // Show placeholder
            const existingPlaceholder = localVideoContainer.querySelector('.placeholder');
            if (existingPlaceholder) {
                existingPlaceholder.remove();
            }
            
            const placeholder = createPlaceholder('Y O U');
            placeholder.classList.add('placeholder');
            localVideoContainer.appendChild(placeholder);
            
            console.log('Video turned OFF - camera released');
            
        } else {
            // ===== TURN VIDEO ON =====
            try {
                // Request ONLY video, don't request audio
                const newStream = await navigator.mediaDevices.getUserMedia({ 
                    video: { facingMode: "user" }
                    // NO audio: true here
                });
                const newVideoTrack = newStream.getVideoTracks()[0];
                
                // Add to local stream
                localStream.addTrack(newVideoTrack);
                
                // Add to peer connections if they exist
                if (typeof peerConnections !== 'undefined') {
                    Object.values(peerConnections).forEach(pc => {
                        pc.addTrack(newVideoTrack, localStream);
                    });
                }
                
                videoBtn.classList.remove('bg-red-600');
                videoIcon.className = 'fa-solid fa-video text-xs sm:text-sm md:text-lg';
                
                // Remove placeholder
                const existingPlaceholder = localVideoContainer.querySelector('.placeholder');
                if (existingPlaceholder) {
                    existingPlaceholder.remove();
                }
                
                // Setup video element - reassign the entire stream
                localVideoElement.srcObject = localStream;
                localVideoElement.style.transform = 'scaleX(-1)';
                await localVideoElement.play();
                
                console.log('Video turned ON');
                
            } catch (err) {
                console.error('Failed to start camera:', err);
                alert('Could not access camera: ' + err.message);
            }
        }
    });
    
    document.getElementById('flipCameraBtn').addEventListener('click', function() {
        this.classList.toggle('bg-teal-600');
    });

    document.getElementById('endCallBtn').addEventListener('click', leave);


    function createPlaceholder(userName) {
        const placeholder = document.createElement('div');
        placeholder.className = 'absolute inset-0 flex items-center justify-center bg-gray-700';
        
        const initials = getUserInitials(userName);
        placeholder.innerHTML = `
            <div class="w-16 h-16 bg-teal-600 rounded-full flex items-center justify-center text-white text-xl font-bold shadow-lg">
                ${initials}
            </div>
        `;
        return placeholder;
    }

    function addRemoteVideo(userId, userName, stream) {
        console.log(`[addRemoteVideo] Called for user ${userId}`, {
            streamId: stream?.id,
            tracks: stream?.getTracks().map(t => `${t.kind}:${t.readyState}`)
        });
        
        const vidId = `video-${userId}`;
        let videoElement = document.getElementById(vidId);
        
        if (!videoElement) {
            console.log(`[addRemoteVideo] Creating new video element for ${userId}`);
            const remoteVideos = document.getElementById('remoteVideos');
            
            const videoContainer = document.createElement('div');
            videoContainer.id = `remote-video-${userId}`;
            videoContainer.className = 'relative bg-gray-800 rounded-lg overflow-hidden border-2 border-teal-500/50 w-full h-full';
            
            videoElement = document.createElement('video');
            videoElement.id = vidId;
            videoElement.className = 'w-full h-full object-cover bg-gray-700';
            videoElement.autoplay = true;
            videoElement.playsInline = true;
            videoElement.muted = false;
            
            // Username overlay
            const userNameElement = document.createElement('div');
            userNameElement.className = 'absolute bottom-2 left-2 bg-black/70 text-white px-2 py-1 rounded text-xs sm:text-sm';
            userNameElement.textContent = userName;
            
            // Add elements
            videoContainer.appendChild(videoElement);
            videoContainer.appendChild(userNameElement);
            remoteVideos.appendChild(videoContainer);
            
            // Update layout
            updateVideoLayout(remoteVideos.children.length);
            
            console.log(`[addRemoteVideo] Video element created for ${userId}`);
        } else {
            console.log(`[addRemoteVideo] Video element already exists for ${userId}`);
        }
        
        // Only set srcObject if it's different or not set
        if (videoElement.srcObject !== stream) {
            console.log(`[addRemoteVideo] Setting srcObject for ${userId}`);
            videoElement.srcObject = stream;
            
            // Wait for metadata before playing
            videoElement.onloadedmetadata = () => {
                console.log(`[addRemoteVideo] âœ… Metadata loaded for ${userId}`, {
                    width: videoElement.videoWidth,
                    height: videoElement.videoHeight
                });
                
                videoElement.play()
                    .then(() => {
                        console.log(`[addRemoteVideo] âœ… play() succeeded for ${userId}`);
                    })
                    .catch(err => {
                        console.error(`[addRemoteVideo] âŒ play() failed for ${userId}:`, err);
                        
                        // Fallback: muted autoplay
                        if (err.name === 'NotAllowedError' || err.name === 'AbortError') {
                            console.log(`[addRemoteVideo] Trying muted autoplay for ${userId}`);
                            videoElement.muted = true;
                            videoElement.play()
                                .then(() => {
                                    setTimeout(() => {
                                        videoElement.muted = false;
                                        console.log(`[addRemoteVideo] Unmuted ${userId}`);
                                    }, 1000);
                                })
                                .catch(e => console.error(`[addRemoteVideo] Even muted play failed:`, e));
                        }
                    });
            };
        } else {
            console.log(`[addRemoteVideo] srcObject already set for ${userId}, skipping`);
        }
    }

    async function handleOffer(userId, msg, iceServers) {
        console.log(`[${userId}] Handling offer message`, msg);
        const remoteId = msg.from ?? msg.user_id ?? msg.sender;
        const userName = msg.user_name || `User ${remoteId}`;
        if (!remoteId) { 
            console.warn('Offer missing remote id'); 
            return; 
        }
        
        console.log(`[${userId}] Received offer from [${remoteId}]`);
        
        // Clean up existing connection
        if (peerConnections[remoteId]) {
            console.log(`[${userId}] Closing existing connection to [${remoteId}]`);
            try { peerConnections[remoteId].close(); } catch (e) { }
            delete peerConnections[remoteId];
            removeRemoteVideo(remoteId);
        }
        
        // Create connection (not initiator, since we're answering)
        const pc = startConnection(userId, remoteId, userName, false, iceServers);
        
        try {
            await pc.setRemoteDescription({ type: 'offer', sdp: msg.sdp });
            const ans = await pc.createAnswer();
            await pc.setLocalDescription(ans);
            
            sendMessage({ 
                type: 'answer', 
                target_user_id: remoteId, 
                sdp: ans.sdp 
            });
            
            console.log(`[${userId}] Answer sent to [${remoteId}]`);
        } catch (err) {
            console.error(`[${userId}] handleOffer error:`, err);
        }
    }

    function getUserInitials(userName) {
        const names = userName.split(' ');
        if (names.length === 1) {
            return names[0].charAt(0).toUpperCase();
        }
        return (names[0].charAt(0) + names[names.length - 1].charAt(0)).toUpperCase();
    }
    
    function updateVideoLayout(videoCount) {
        const remoteVideos = document.getElementById('remoteVideos');
        const localVideoContainer = document.getElementById('localVideoContainer');
        const isMobile = window.innerWidth < 640; // Mobile breakpoint (Tailwind 'sm')
        
        // Completely reset all grid-related classes and styles
        remoteVideos.className = 'w-full h-full grid gap-0.5 sm:gap-1 p-0.5 sm:p-1 overflow-auto';
        remoteVideos.style.gridAutoRows = '';
        
        // Count actual remote videos (excluding local video if it's in the grid)
        const actualRemoteCount = remoteVideos.contains(localVideoContainer) ? videoCount - 1 : videoCount;
        
        // Handle local video placement (only on mobile if >2 remote users)
        if (actualRemoteCount > 2 && isMobile) {
            // Move local video into grid
            if (!remoteVideos.contains(localVideoContainer)) {
                localVideoContainer.className = 'relative bg-gray-800 rounded-lg overflow-hidden border-2 border-teal-500 shadow-lg w-full h-full';
                localVideoContainer.style.maxHeight = '';
                localVideoContainer.style.maxWidth = '';
                remoteVideos.appendChild(localVideoContainer);
            }
            // Set equal row heights for mobile grid
            remoteVideos.style.gridAutoRows = '1fr';
        } else {
            // Return local video to absolute position
            if (remoteVideos.contains(localVideoContainer)) {
                remoteVideos.removeChild(localVideoContainer);
                localVideoContainer.className = 'absolute bottom-4 right-4 w-48 h-36 sm:w-56 sm:h-40 md:w-64 md:h-48 lg:w-72 lg:h-52 bg-gray-800 rounded-lg overflow-hidden border-2 border-teal-500 shadow-lg z-10';
                localVideoContainer.style.maxHeight = '200px';
                localVideoContainer.style.maxWidth = '300px';
                document.querySelector('.flex-1').appendChild(localVideoContainer);
            }
        }

        // Adjust grid columns based on actual remote video count
        if (actualRemoteCount === 0) {
            remoteVideos.classList.add('grid-cols-1');
        } else if (actualRemoteCount === 1) {
            remoteVideos.classList.add('grid-cols-1');
        } else if (actualRemoteCount === 2) {
            remoteVideos.classList.add('grid-cols-1', 'sm:grid-cols-2');
        } else if (actualRemoteCount <= 4) {
            remoteVideos.classList.add('grid-cols-2', 'sm:grid-cols-2');
        } else {
            remoteVideos.classList.add('grid-cols-2', 'sm:grid-cols-2', 'lg:grid-cols-3');
        }
    }
    
    function removeRemoteVideo(userId) {
        const videoElement = document.getElementById(`remote-video-${userId}`);
        if (videoElement) {
            videoElement.remove();
            const remoteVideos = document.getElementById('remoteVideos');
            updateVideoLayout(remoteVideos.children.length);
        }
    }

    // Add resize event listener to update layout on window resize
    window.addEventListener('resize', () => {
        const remoteVideos = document.getElementById('remoteVideos');
        updateVideoLayout(remoteVideos.children.length);
    });

    // Initial layout update on load
    window.addEventListener('load', () => {
        const remoteVideos = document.getElementById('remoteVideos');
        updateVideoLayout(remoteVideos.children.length);

        connect(parseInt('{{ user_id }}'));
    });

    const sendUserMessageBtn = document.getElementById('sendUserMessage');
    sendUserMessageBtn.addEventListener('click', sendUserMessage);
    const messageInputField = document.getElementById('userMessageInput');
    messageInputField.addEventListener('keypress', function(event) {
        if (event.key === 'Enter') {
            event.preventDefault();
            sendUserMessage();
        }
    });

    function sendUserMessage(){
        const messageInput = document.getElementById('userMessageInput');
        const message = messageInput.value.trim();
        if (message) {
            const messageContent = document.getElementById('messageContent');
            const messageElement = document.createElement('div');
            messageElement.className = 'flex items-center justify-between p-2 bg-gray-800 rounded';
            messageElement.innerHTML = `
                <span>You: ${message}</span>
                <div class="w-2 h-2 bg-teal-500 rounded-full"></div>
            `;
            messageContent.appendChild(messageElement);
            messageInput.value = '';
            messageContent.scrollTop = messageContent.scrollHeight;
        }
    };

    async function connect(userId) {
        try {
            const iceServers = {{ ice_servers | safe }};
            const roomId = '{{ room_id }}';
            
            // ONLY get audio initially - NO VIDEO
            localStream = await navigator.mediaDevices.getUserMedia({
                audio: true,
                    video: { facingMode: "user" }
            });
            
            const videoElement = document.getElementById('localVideo');
            videoElement.srcObject = localStream;
            videoElement.muted = true;
            videoElement.style.transform = 'scaleX(-1)';
            
            const serverUrl = `https://himalpoudel.name.np/vibecall/call/ws/rooms`;
            ws = new WebSocket(`${serverUrl}/${roomId}`);
            
            ws.onopen = () => {
                sendMessage({ type: 'join', room_id: roomId, user_id: userId });
            };
            
            ws.onmessage = async (evt) => {
                try {
                    const msg = JSON.parse(evt.data);
                    await handleSignalingMessage(userId, msg, iceServers);
                } catch (err) {
                    console.error('Invalid message', err);
                }
            };
            
            ws.onerror = (e) => console.error('WebSocket error', e);
            ws.onclose = () => {
                cleanup();
            };
        } catch (err) {
            console.error('Failed to get media / TURN', err);
            alert('Could not access camera/microphone or TURN failed: ' + err);
        }
    }

    async function handleSignalingMessage(userId, msg, iceServers) {
        switch (msg.type) {
            case 'user-joined':
                updateUsersList(msg.users);
                
                const isMyJoin = msg.user_id === userId;
                
                if (isMyJoin) {
                    (msg.users || []).forEach(([remoteId, username]) => {
                        if (remoteId === userId) return;
                        if (!peerConnections[remoteId]) {
                            console.log(`[${userId}] I joined - INITIATING to existing user [${remoteId}]`);
                            startConnection(userId, remoteId, username, true, iceServers);
                        }
                    });
                } else {
                    // Someone else joined - they will initiate to me, I do nothing
                    console.log(`[${userId}] User [${msg.user_id}] joined - waiting for their offer`);
                    // Don't create connection - wait for offer from the new joiner
                }
                break;

            case 'offer':
                await handleOffer(userId, msg, iceServers);
                break;

            case 'answer':
                {
                    const remoteId = msg.from ?? msg.user_id ?? msg.sender;
                    const pc = peerConnections[remoteId];
                    if (pc) {
                        if (pc.signalingState !== 'stable') {
                            await pc.setRemoteDescription({ type: 'answer', sdp: msg.sdp });
                        } else {
                            console.warn(`Answer received for peer ${remoteId} but signaling state is stable. Ignoring.`);
                        }
                    } else {
                        console.warn('Answer for unknown peer', remoteId);
                    }
                }
                break;

            case 'ice-candidate':
                {
                    const remoteId = msg.from ?? msg.user_id ?? msg.sender;
                    const pc = peerConnections[remoteId];
                    if (pc && msg.candidate) {
                        try {
                            await pc.addIceCandidate({
                                candidate: msg.candidate,
                                sdpMid: msg.sdp_mid,
                                sdpMLineIndex: msg.sdp_m_line_index
                            });
                        } catch (err) {
                            console.warn('addIceCandidate failed', err);
                        }
                    }
                }
                break;

            case 'user-left':
                const uid = msg.user_id;
                if (peerConnections[uid]) {
                    try { peerConnections[uid].close(); } catch (e) { }
                    delete peerConnections[uid];
                }
                removeRemoteVideo(uid);
                updateUsersList(msg.users);
                break;

            case 'error':
                console.error('Server error:', msg.message);
                alert('Server error: ' + msg.message);
                break;

            default:
                console.log('Unknown msg type', msg.type);
        }
    }


    function startConnection(userId, remoteId, label = '', isInitiator = false, iceServers) {
        console.log(`[${userId}] Creating ${isInitiator ? 'INITIATOR' : 'RECEIVER'} connection to [${remoteId}]`);
    
        const pc = new RTCPeerConnection({ iceServers: iceServers });
        peerConnections[remoteId] = pc;
    
        // Add local tracks
        if (localStream) {
            localStream.getTracks().forEach(track => {
                console.log(`[${userId}] Adding ${track.kind} track to [${remoteId}]:`, track.readyState);
                pc.addTrack(track, localStream);
            });
        } else {
            console.warn(`[${userId}] No localStream when creating connection to [${remoteId}]`);
        }
        
        pc.ontrack = (ev) => {
            console.log(`[${userId}] ðŸŽ¥ ontrack from [${remoteId}]:`, ev.track.kind, ev.track.readyState);
            
            if (ev.streams && ev.streams[0]) {
                const stream = ev.streams[0];
                
                // Store or update the stream reference
                if (!remoteStreams[remoteId]) {
                    // First track received - create video element
                    console.log(`[${userId}] First track from [${remoteId}], creating video element`);
                    remoteStreams[remoteId] = stream;
                    addRemoteVideo(remoteId, label || `User ${remoteId}`, stream);
                } else {
                    // Subsequent tracks - stream is already set, do nothing
                    console.log(`[${userId}] Additional track from [${remoteId}], video already exists`);
                    // The stream object already has both tracks, no need to update
                }
            }
        };        
        pc.onicecandidate = (ev) => {
            if (ev.candidate) {
                sendMessage({
                    type: 'ice_candidate',
                    target_user_id: remoteId,
                    candidate: ev.candidate.candidate,
                    sdp_mid: ev.candidate.sdpMid,
                    sdp_m_line_index: ev.candidate.sdpMLineIndex
                });
            }
        };
        
        let isNegotiating = false;
        pc.onnegotiationneeded = async () => {
            if (!isInitiator || pc.signalingState !== 'stable' || isNegotiating) {
                return;
            }
            try {
                isNegotiating = true;
                await pc.setLocalDescription();
                sendMessage({
                    type: 'offer',
                    target_user_id: remoteId,
                    sdp: pc.localDescription.sdp
                });
            } catch (err) {
                console.error('onnegotiationneeded failed to create offer', err);
            } finally {
                isNegotiating = false;
            }
        };
        
        pc.oniceconnectionstatechange = () => {
            console.log(`ICE connection state for ${remoteId}: ${pc.iceConnectionState}`);
        };
        
        pc.onconnectionstatechange = () => {
            console.log(`Connection state for ${remoteId}: ${pc.connectionState}`);
        };
        
        if (isInitiator) {
            setTimeout(() => {
                if (pc.signalingState === 'stable') {
                    pc.dispatchEvent(new Event('negotiationneeded'));
                }
            }, 0);
        }
        
        return pc;
    }

    function sendMessage(msg) {
        if (ws && ws.readyState === WebSocket.OPEN) {
            ws.send(JSON.stringify(msg));
        }

    }


    function updateUsersList(users) {
        const currentUserId = parseInt('{{ user_id }}');
        let usersContent = document.getElementById('usersContent');
        if (!users || users.length === 0) {
            usersContent.textContent = 'None';
        } else {
            usersContent.innerHTML = users.map(u => {
                const [id, name] = u;

            return `
                <div class="flex items-center justify-between p-2 bg-gray-800 rounded">
                    <span>ðŸ‘¤ ${name} ${id === currentUserId ? '(You)' : ''}</span>
                    <div class="w-2 h-2 bg-teal-500 rounded-full"></div>
                </div>`;
            }).join('');
        }
    }

    function leave() {
        if (ws && ws.readyState === WebSocket.OPEN) {
            sendMessage({ type: 'leave', room_id: '{{ room_id }}' });
            ws.close();
        }
        cleanup();
    }

    function cleanup() {
        Object.values(peerConnections).forEach(pc => {
            try { pc.close(); } catch (e) { }
        });
        peerConnections = {};

        if (localStream) localStream.getTracks().forEach(t => { try { t.stop(); } catch (e) { } });
        localStream = null;

        updateUsersList([]);
        controlsRow.style.display = 'none';
        joinContainer.style.display = 'block';
        connectBtn.disabled = false;
        leaveBtn.disabled = true;
        toggleMicBtn.disabled = true;
        toggleVideoBtn.disabled = true;
        flipCameraBtn.disabled = true;
        currentFacingMode = 'user';

        updateStatus('Disconnected', false);
    }


    // Users list toggle functionality
    document.getElementById('usersListToggle').addEventListener('click', function() {
        const messagePanel = document.getElementById('userMessagePanel');
        const usersPanel = document.getElementById('usersListPanel');
        if (!messagePanel.classList.contains('hidden')) {
            messagePanel.classList.add('hidden');
        }
        usersPanel.classList.toggle('hidden');
        this.classList.toggle('bg-teal-600');
    });

    document.getElementById('userMessageBtn').addEventListener('click', function() {
        const usersPanel = document.getElementById('usersListPanel');
        const messagePanel = document.getElementById('userMessagePanel');
        if (!usersPanel.classList.contains('hidden')) {
            usersPanel.classList.add('hidden');
        }
        messagePanel.classList.toggle('hidden');
    });

    // Control buttons (unchanged)
    // MIC TOGGLE
    document.getElementById('toggleMicBtn').addEventListener('click', function () {
        if (!localStream) return;
        const track = localStream.getAudioTracks()[0];
        if (!track) return;
    
        track.enabled = !track.enabled;
        const micIcon = document.getElementById('micIcon');
    
        if (!track.enabled) {
            this.classList.add('bg-red-600');
            micIcon.className = 'fa-solid fa-microphone-slash text-xs sm:text-sm md:text-lg';
        } else {
            this.classList.remove('bg-red-600');
            micIcon.className = 'fa-solid fa-microphone text-xs sm:text-sm md:text-lg';
        }
    });

</script>
{% endblock %}
